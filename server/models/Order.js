// Order Model for WaveMAX Laundry Affiliate Program

const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');
const SystemConfig = require('./SystemConfig');

// Order Schema
const orderSchema = new mongoose.Schema({
  orderId: {
    type: String,
    default: () => 'ORD-' + uuidv4(),
    unique: true
  },
  customerId: { type: String, required: true, ref: 'Customer' },
  affiliateId: { type: String, required: true, ref: 'Affiliate' },
  // Pickup information
  pickupDate: { type: Date, required: true },
  pickupTime: {
    type: String,
    enum: ['morning', 'afternoon', 'evening'],
    required: true
  },
  specialPickupInstructions: String,
  estimatedWeight: {
    type: Number,
    required: true,
    min: 0.1
  },
  // Order status
  status: {
    type: String,
    enum: ['pending', 'processing', 'processed', 'complete', 'cancelled'],
    default: 'pending'
  },
  // Laundry details
  actualWeight: Number,
  washInstructions: String,
  // Bag information
  numberOfBags: { type: Number, default: 1, min: 1 },
  bagsWeighed: { type: Number, default: 0 },
  bagsProcessed: { type: Number, default: 0 }, // Bags scanned after WDF process
  bagsPickedUp: { type: Number, default: 0 },
  // Individual bag weights (legacy - kept for backward compatibility)
  bagWeights: [{
    bagNumber: Number,
    weight: Number,
    receivedAt: Date
  }],
  // New bag tracking system
  bags: [{
    bagId: {
      type: String,
      required: true,
      index: true
    },
    bagNumber: {
      type: Number,
      required: true
    },
    status: {
      type: String,
      enum: ['processing', 'processed', 'completed'],
      default: 'processing'
    },
    weight: {
      type: Number,
      default: 0
    },
    scannedAt: {
      processing: Date,
      processed: Date,
      completed: Date
    },
    scannedBy: {
      processing: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' },
      processed: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' },
      completed: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' }
    }
  }],
  // Add-on services
  addOns: {
    premiumDetergent: { type: Boolean, default: false },
    fabricSoftener: { type: Boolean, default: false },
    stainRemover: { type: Boolean, default: false }
  },
  addOnTotal: { type: Number, default: 0 }, // Calculated cost of add-ons
  // Payment information
  baseRate: { type: Number }, // Per pound WDF rate - fetched from SystemConfig
  // Fee breakdown structure
  feeBreakdown: {
    numberOfBags: Number,
    minimumFee: Number,
    perBagFee: Number,
    totalFee: Number, // The actual fee charged (greater of minimum or calculated)
    minimumApplied: Boolean
  },
  estimatedTotal: Number,
  actualTotal: Number,
  // Bag Credit tracking
  bagCreditApplied: { type: Number, default: 0 }, // Bag credit applied to this order
  // WDF Credit tracking
  wdfCreditApplied: { type: Number, default: 0 }, // Amount of credit applied to this order
  wdfCreditGenerated: { type: Number, default: 0 }, // Credit generated by weight difference
  weightDifference: { type: Number, default: 0 }, // actualWeight - estimatedWeight
  affiliateCommission: { type: Number, default: 0 },
  paymentStatus: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'refunded', 'failed'],
    default: 'pending'
  },
  paymentMethod: {
    type: String,
    enum: ['card', 'cash', 'other'],
    default: 'card'
  },
  paymentDate: Date,
  paymentReference: String,
  paymentError: String,
  refundAmount: Number,
  refundReason: String,
  refundReference: String,
  refundedAt: Date,
  isPaid: { type: Boolean, default: false },
  // Operator processing fields
  assignedOperator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Operator'
  },
  operatorNotes: String,
  qualityCheckPassed: {
    type: Boolean,
    default: null
  },
  qualityCheckBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Operator'
  },
  qualityCheckNotes: String,
  processingTimeMinutes: Number, // Auto-calculated
  
  // V2 Payment System Fields
  transactionId: String, // Transaction ID from successful payment
  wdfAmount: Number, // Weekly delivery fee amount
  mdfAmount: Number, // Minimum delivery fee amount
  v2PaymentStatus: {
    type: String,
    enum: ['pending', 'awaiting', 'confirming', 'verified', 'failed'],
    default: 'pending'
  },
  v2PaymentMethod: {
    type: String,
    default: 'pending'
  },
  v2PaymentAmount: {
    type: Number,
    default: 0
  },
  paidAmount: Number, // Actual amount paid (for partial payments)
  paymentDetails: {
    type: mongoose.Schema.Types.Mixed, // Store card details, auth codes, etc.
    default: {}
  },
  v2PaymentRequestedAt: Date,
  v2PaymentConfirmedAt: Date, // When customer clicked "already paid"
  v2PaymentVerifiedAt: Date,
  v2PaymentTransactionId: String,
  v2PaymentLinks: {
    venmo: String,
    paypal: String,
    cashapp: String
  },
  v2PaymentQRCodes: {
    venmo: String, // Base64 encoded
    paypal: String,
    cashapp: String
  },
  v2PaymentCheckAttempts: {
    type: Number,
    default: 0
  },
  v2LastPaymentCheck: Date,
  v2PaymentNotes: String, // For storing verification details
  v2PaymentReminderCount: {
    type: Number,
    default: 0
  },
  v2PaymentLastReminderAt: Date,
  
  // V2 Payment Reminder Tracking
  v2PaymentReminders: [{
    sentAt: { type: Date, required: true },
    reminderNumber: { type: Number, required: true },
    sentBy: { type: mongoose.Schema.Types.ObjectId, ref: 'Administrator' },
    method: { type: String, enum: ['email', 'sms'], default: 'email' }
  }],
  v2LastReminderSentAt: Date,
  v2ReminderCount: { type: Number, default: 0 },
  
  // Test order flag for cleanup
  isTestOrder: { type: Boolean, default: false },
  
  // Timestamps
  createdAt: { type: Date, default: Date.now }, // When order was created (pending state)
  processingStartedAt: Date, // When order was received and WDF started
  processedAt: Date, // When order is ready for affiliate pickup
  completedAt: Date, // When affiliate delivered the order
  cancelledAt: Date
}, { timestamps: true });

// Middleware for calculating estimated total before saving
orderSchema.pre('save', async function(next) {
  // Fetch current WDF rate from system config if not explicitly set
  if (this.isNew && !this.baseRate) {
    try {
      this.baseRate = await SystemConfig.getValue('wdf_base_rate_per_pound', 1.25);
    } catch (error) {
      // If SystemConfig is not available, use default
      this.baseRate = 1.25;
    }
  }

  // Calculate add-on total if add-ons are selected
  if (this.isNew || this.isModified('addOns') || this.isModified('estimatedWeight') || this.isModified('actualWeight')) {
    const weight = this.actualWeight || this.estimatedWeight;
    const selectedAddOns = Object.values(this.addOns || {}).filter(selected => selected === true).length;
    this.addOnTotal = parseFloat((selectedAddOns * weight * 0.10).toFixed(2));
  }

  if (this.isNew || this.isModified('estimatedWeight') || this.isModified('baseRate') || this.isModified('feeBreakdown') || this.isModified('wdfCreditApplied') || this.isModified('bagCreditApplied') || this.isModified('addOns')) {
    // Calculate estimated total using the provided estimated weight
    const totalFee = this.feeBreakdown?.totalFee || 0;
    const wdfTotal = this.estimatedWeight * this.baseRate;
    const subtotal = wdfTotal + totalFee + (this.addOnTotal || 0);
    // Apply both bag credit and WDF credit (subtract if positive credit, add if negative/debit)
    this.estimatedTotal = parseFloat((subtotal - (this.bagCreditApplied || 0) - (this.wdfCreditApplied || 0)).toFixed(2));
  }

  // Calculate actual total if actual weight is available
  if (this.isModified('actualWeight') && this.actualWeight) {
    const totalFee = this.feeBreakdown?.totalFee || 0;
    const wdfTotal = this.actualWeight * this.baseRate;
    const subtotal = wdfTotal + totalFee + (this.addOnTotal || 0);
    // Apply both bag credit and WDF credit (subtract if positive credit, add if negative/debit)
    this.actualTotal = parseFloat((subtotal - (this.bagCreditApplied || 0) - (this.wdfCreditApplied || 0)).toFixed(2));
    
    // For V2 orders, calculate payment amount without credits
    this.v2PaymentAmount = parseFloat((wdfTotal + totalFee + (this.addOnTotal || 0)).toFixed(2));
    
    // Calculate affiliate commission (10% of WDF + full delivery fee)
    // Commission = (WDF amount Ã— 10%) + delivery fee
    // NOTE: Add-ons and credits are NOT included in commission calculation
    const wdfAmount = this.actualWeight * this.baseRate;
    const wdfCommission = wdfAmount * 0.1;
    this.affiliateCommission = parseFloat((wdfCommission + totalFee).toFixed(2));
  }

  // Update isPaid when v2PaymentStatus changes to verified
  if (this.isModified('v2PaymentStatus')) {
    if (this.v2PaymentStatus === 'verified') {
      this.isPaid = true;
      if (!this.paymentDate) {
        this.paymentDate = new Date();
      }
    }
  }

  // Update status timestamps
  if (this.isModified('status')) {
    const now = new Date();
    switch (this.status) {
    case 'processing':
      if (!this.processingStartedAt) this.processingStartedAt = now;
      break;
    case 'processed':
      if (!this.processedAt) this.processedAt = now;
      break;
    case 'complete':
      if (!this.completedAt) this.completedAt = now;
      break;
    case 'cancelled':
      if (!this.cancelledAt) this.cancelledAt = now;
      break;
    }
  }

  next();
});

// Create model
const Order = mongoose.model('Order', orderSchema);

module.exports = Order;