// Order Model for WaveMAX Laundry Affiliate Program

const mongoose = require('mongoose');
const SystemConfig = require('./SystemConfig');

// Order Schema
const orderSchema = new mongoose.Schema({
  orderId: {
    type: String,
    default: () => 'ORD' + Math.floor(100000 + Math.random() * 900000),
    unique: true
  },
  customerId: { type: String, required: true, ref: 'Customer' },
  affiliateId: { type: String, required: true, ref: 'Affiliate' },
  // Pickup information
  pickupDate: { type: Date, required: true },
  pickupTime: {
    type: String,
    enum: ['morning', 'afternoon', 'evening'],
    required: true
  },
  specialPickupInstructions: String,
  estimatedWeight: {
    type: Number,
    required: true,
    min: 0.1
  },
  // Order status
  status: {
    type: String,
    enum: ['pending', 'processing', 'processed', 'complete', 'cancelled'],
    default: 'pending'
  },
  // Laundry details
  actualWeight: Number,
  washInstructions: String,
  // Bag information
  numberOfBags: { type: Number, default: 1, min: 1 },
  bagsWeighed: { type: Number, default: 0 },
  bagsProcessed: { type: Number, default: 0 }, // Bags scanned after WDF process
  bagsPickedUp: { type: Number, default: 0 },
  // Individual bag weights (legacy - kept for backward compatibility)
  bagWeights: [{
    bagNumber: Number,
    weight: Number,
    receivedAt: Date
  }],
  // New bag tracking system
  bags: [{
    bagId: {
      type: String,
      required: true,
      index: true
    },
    bagNumber: {
      type: Number,
      required: true
    },
    status: {
      type: String,
      enum: ['processing', 'processed', 'completed'],
      default: 'processing'
    },
    weight: {
      type: Number,
      default: 0
    },
    scannedAt: {
      processing: Date,
      processed: Date,
      completed: Date
    },
    scannedBy: {
      processing: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' },
      processed: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' },
      completed: { type: mongoose.Schema.Types.ObjectId, ref: 'Operator' }
    }
  }],
  // Payment information
  baseRate: { type: Number }, // Per pound WDF rate - fetched from SystemConfig
  // Fee breakdown structure
  feeBreakdown: {
    numberOfBags: Number,
    minimumFee: Number,
    perBagFee: Number,
    totalFee: Number, // The actual fee charged (greater of minimum or calculated)
    minimumApplied: Boolean
  },
  estimatedTotal: Number,
  actualTotal: Number,
  // WDF Credit tracking
  wdfCreditApplied: { type: Number, default: 0 }, // Amount of credit applied to this order
  wdfCreditGenerated: { type: Number, default: 0 }, // Credit generated by weight difference
  weightDifference: { type: Number, default: 0 }, // actualWeight - estimatedWeight
  affiliateCommission: { type: Number, default: 0 },
  paymentStatus: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'refunded', 'failed'],
    default: 'pending'
  },
  paymentMethod: {
    type: String,
    enum: ['card', 'cash', 'other'],
    default: 'card'
  },
  paymentDate: Date,
  paymentReference: String,
  paymentError: String,
  refundAmount: Number,
  refundReason: String,
  refundReference: String,
  refundedAt: Date,
  // Operator processing fields
  assignedOperator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Operator'
  },
  operatorNotes: String,
  qualityCheckPassed: {
    type: Boolean,
    default: null
  },
  qualityCheckBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Operator'
  },
  qualityCheckNotes: String,
  processingTimeMinutes: Number, // Auto-calculated
  // Timestamps
  createdAt: { type: Date, default: Date.now }, // When order was created (pending state)
  processingStartedAt: Date, // When order was received and WDF started
  processedAt: Date, // When order is ready for affiliate pickup
  completedAt: Date, // When affiliate delivered the order
  cancelledAt: Date
}, { timestamps: true });

// Middleware for calculating estimated total before saving
orderSchema.pre('save', async function(next) {
  // Fetch current WDF rate from system config if not explicitly set
  if (this.isNew && !this.baseRate) {
    try {
      this.baseRate = await SystemConfig.getValue('wdf_base_rate_per_pound', 1.25);
    } catch (error) {
      // If SystemConfig is not available, use default
      this.baseRate = 1.25;
    }
  }

  if (this.isNew || this.isModified('estimatedWeight') || this.isModified('baseRate') || this.isModified('feeBreakdown') || this.isModified('wdfCreditApplied')) {
    // Calculate estimated total using the provided estimated weight
    const totalFee = this.feeBreakdown?.totalFee || 0;
    const subtotal = this.estimatedWeight * this.baseRate + totalFee;
    // Apply WDF credit (subtract if positive credit, add if negative/debit)
    this.estimatedTotal = parseFloat((subtotal - (this.wdfCreditApplied || 0)).toFixed(2));
  }

  // Calculate actual total if actual weight is available
  if (this.isModified('actualWeight') && this.actualWeight) {
    const totalFee = this.feeBreakdown?.totalFee || 0;
    const subtotal = this.actualWeight * this.baseRate + totalFee;
    // Apply WDF credit (subtract if positive credit, add if negative/debit)
    this.actualTotal = parseFloat((subtotal - (this.wdfCreditApplied || 0)).toFixed(2));
    // Calculate affiliate commission (10% of WDF + full delivery fee)
    // Commission = (WDF amount Ã— 10%) + delivery fee
    const wdfAmount = this.actualWeight * this.baseRate;
    const wdfCommission = wdfAmount * 0.1;
    this.affiliateCommission = parseFloat((wdfCommission + totalFee).toFixed(2));
  }

  // Update status timestamps
  if (this.isModified('status')) {
    const now = new Date();
    switch (this.status) {
    case 'processing':
      if (!this.processingStartedAt) this.processingStartedAt = now;
      break;
    case 'processed':
      if (!this.processedAt) this.processedAt = now;
      break;
    case 'complete':
      if (!this.completedAt) this.completedAt = now;
      break;
    case 'cancelled':
      if (!this.cancelledAt) this.cancelledAt = now;
      break;
    }
  }

  next();
});

// Create model
const Order = mongoose.model('Order', orderSchema);

module.exports = Order;